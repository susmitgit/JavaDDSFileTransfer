

package rti.examples.JavaDDSFileTransfer;

/* FileFragmentSubscriber.java

A publication of data of type FileFragment

This file is derived from code automatically generated by the rtiddsgen 
command:

rtiddsgen -language java -example <arch> .idl

Example publication of type FileFragment automatically generated by 
'rtiddsgen' To test them follow these steps:

(1) Compile this file and the example subscription.

(2) Start the subscription on the same domain used for RTI Data Distribution
Service with the command
java FileFragmentSubscriber <domain_id> <sample_count>

(3) Start the publication on the same domain used for RTI Data Distribution
Service with the command
java FileFragmentPublisher <domain_id> <sample_count>

(4) [Optional] Specify the list of discovery initial peers and 
multicast receive addresses via an environment variable or a file 
(in the current working directory) called NDDS_DISCOVERY_PEERS. 

You can run any number of publishers and subscribers programs, and can 
add and remove them dynamically from the domain.

Example:

To run the example application on domain <domain_id>:

Ensure that $(NDDSHOME)/lib/<arch> is on the dynamic library path for
Java.                       

On UNIX systems: 
add $(NDDSHOME)/lib/<arch> to the 'LD_LIBRARY_PATH' environment
variable

On Windows systems:
add %NDDSHOME%\lib\<arch> to the 'Path' environment variable

Run the Java applications:

java -Djava.ext.dirs=$NDDSHOME/class FileFragmentPublisher <domain_id>

java -Djava.ext.dirs=$NDDSHOME/class FileFragmentSubscriber <domain_id>  
*/


import java.io.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import com.rti.dds.domain.*;
import com.rti.dds.infrastructure.*;
import com.rti.dds.subscription.*;
import com.rti.dds.topic.*;

import rti.examples.JavaDDSFileTransfer.FilePublisher.Opt;
import rti.examples.util.ProgramOptions;
import rti.examples.util.ProgramOptions.Option;

// ===========================================================================

public class FileSubscriber {
    
    private static String qos_library = new String ("DDSFileTransferLibrary");
    private static String qos_profile = new String("FileTransferQos");
    static File baseDirectory = null;
    static DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    static Calendar cal = Calendar.getInstance();
    private static final String LOG_DATE = "[" + dateFormat.format(cal.getTime()) + "] - "; 
    /**
     * An output stream for the current file. This member may be null if there
     * is no current file or if the file couldn't be created for writing.
     */
    private static OutputStream outputStream;
 
    
    /**
     * A local byte buffer for temporary storage of file data.
     */
    private static final byte[] buffer = new byte[FILE_FRAGMENT_SIZE_MAX.VALUE];
    
    /**
     * The count of bytes written for the current file. This is used to check
     * the consistency between the files reconstructed and what their 
     * description states.
     */
    private static long bytesWrittenCurrentFile;
    
    /**
     * The description of the current file. This member is used for consistency
     * checking.
     */
    private static String currentFileName;
    
    /**
     * The next fragment number that is expected. This member is used for
     * consistency checking.
     */
    private static int nextfragmentNumberExpected;
    
    /**
     * Indicates whether there is an error with the current file.
     */
    private static boolean errorWithCurrentFile;
    
    /**
     * The <code>File</code> object representing the file currently being
     * processed.
     */
    private static File currentFile;

    /**
     * FilePublisher command-line options.
     */
    static final class Opt {
        /**
         * Used to manipulate Options as a group.
         */
        static ProgramOptions All = new ProgramOptions();

        /**
         * Specifies domain ID for participant (0 by default).
         */
        static final Option DOMAIN_ID = Option.makeOption(All, "domainID", int.class, "57");

        /**
         * Root directory from which to publish files.
         */
        static final Option BASE_DIRECTORY = Option.makeStringOption(All, "baseDir", ".");
        
        static final Option TOPIC_NAME = Option.makeStringOption(All, "topic", "FileFragments");
    }
    
    // -----------------------------------------------------------------------
    // Public Methods
    // -----------------------------------------------------------------------

    public static void main(String[] args) {

        int domainId = 0;
        new writeLog().writeOut("\n "
    			+ LOG_DATE + " ( "+ Opt.DOMAIN_ID.asInt() +" ) "+  Opt.TOPIC_NAME.asString() 
    			+ " - SUB - " + " => " + "Subscriber started ...");
        try {
            Opt.All.parseOptions(args);
        } catch (IllegalArgumentException iae) {
            System.err.println("Unknown option: " + iae.getMessage());
            System.err.println("Usage: \n" + Opt.All.getPrintableDescription());
            System.exit(-1);
        }

        
        // Confirm that directory containing files to publish exists
        String baseDir = Opt.BASE_DIRECTORY.asString();
        
        baseDirectory = new File(baseDir).getAbsoluteFile();
        if (!baseDirectory.exists()) {
            System.err.println("Base directory does not exist: " + baseDirectory);
            System.exit(-1);
        }
        
        resetForNextFile();
        
        domainId = Opt.DOMAIN_ID.asInt();

        // --- Run --- //
        subscriberMain(domainId);
    }


    // -----------------------------------------------------------------------
    // Private Methods
    // -----------------------------------------------------------------------

    // --- Constructors: -----------------------------------------------------

    private FileSubscriber() {
        super();
    }

    // -----------------------------------------------------------------------

    private static void subscriberMain(int domainId) {

        DomainParticipant participant = null;
        Subscriber subscriber = null;
        Topic topic = null;
        FileFragmentDataReader reader = null;
        
        try {

            participant = DomainParticipantFactory.TheParticipantFactory.
            create_participant_with_profile(
                domainId, qos_library, qos_profile,
                null , StatusKind.STATUS_MASK_NONE);
            if (participant == null) {
                System.err.println("create_participant error\n");
                return;
            }                         

            subscriber = participant.create_subscriber(
                DomainParticipant.SUBSCRIBER_QOS_DEFAULT, null /* listener */,
                StatusKind.STATUS_MASK_NONE);
            if (subscriber == null) {
                System.err.println("create_subscriber error\n");
                return;
            }     

            String typeName = FileFragmentTypeSupport.get_type_name();
            FileFragmentTypeSupport.register_type(participant, typeName);

            topic = participant.create_topic(
                Opt.TOPIC_NAME.asString(),
                typeName, DomainParticipant.TOPIC_QOS_DEFAULT,
                null, StatusKind.STATUS_MASK_NONE);
            if (topic == null) {
                System.err.println("create_topic error\n");
                return;
            }           
                
            reader = (FileFragmentDataReader)
            subscriber.create_datareader_with_profile(
                topic, qos_library, qos_profile,
                null , StatusKind.STATUS_MASK_NONE);
            if (reader == null) {
                System.err.println("create_datareader error\n");
                return;
            }                         

            // --- Main Loop --- //
            WaitSet waitset = new WaitSet();
            
            // Wait for new data on reader
            ConditionSeq active_conditions = new ConditionSeq(); 
            StatusCondition cond = reader.get_statuscondition();
            cond.set_enabled_statuses(StatusKind.DATA_AVAILABLE_STATUS);
            
            waitset.attach_condition(cond);
            
            FileFragmentSeq dataSeq = new FileFragmentSeq();
            SampleInfoSeq infoSeq = new SampleInfoSeq();
            int chunk_count=0;
            while(true) {
            	
                try {
                    waitset.wait(active_conditions, Duration_t.DURATION_INFINITE);

                    try {
                        reader.take(
                            dataSeq, infoSeq,
                            ResourceLimitsQosPolicy.LENGTH_UNLIMITED,
                            SampleStateKind.ANY_SAMPLE_STATE,
                            ViewStateKind.ANY_VIEW_STATE,
                            InstanceStateKind.ANY_INSTANCE_STATE);

                        for (int i = 0; i < dataSeq.size(); ++i) {
                            SampleInfo info = (SampleInfo)infoSeq.get(i);

                            if (info.valid_data) {
                            	chunk_count++;	
                            	FileFragment frag=(FileFragment)dataSeq.get(i);
                          	  new writeLog().writeOut("\n "
                                  		+ LOG_DATE + " ( "+ Opt.DOMAIN_ID.asInt() +" ) "+ Opt.TOPIC_NAME.asString() + " - SUB - " + " => " + frag.file_name +" File chunk [ "+ chunk_count +" ] receive write starts at - >   [ "+ new Date().getTime() + " ] ms ");
                          
                                processFragment((FileFragment)dataSeq.get(i));
                                new writeLog().writeOut("\n "
                                  		+ LOG_DATE + " ( "+ Opt.DOMAIN_ID.asInt() +" ) "+ Opt.TOPIC_NAME.asString() + " - SUB - " + " => " + frag.file_name +" File chunk [ "+ chunk_count +" ] receive write ends at - >   [ "+ new Date().getTime() + " ] ms ");
                          
                            }
                        }
                    } catch (RETCODE_NO_DATA noData) {
                        // No data to process
                    } finally {
                        reader.return_loan(dataSeq, infoSeq);
                    }
                } catch (RETCODE_ERROR err) {
                    // ... check for cause of failure
                    System.err.println("Got error " + err.toString());
                }
            }
        } finally {

            // --- Shutdown --- //

            if(participant != null) {
                participant.delete_contained_entities();

                DomainParticipantFactory.TheParticipantFactory.
                delete_participant(participant);
            }
        }
    }
    
    /**
     * Process the given <code>FileFragment</code>. This method will start a new
     * file if the argument is the first fragment. If the argument is the last
     * fragment, then this method will close the file. In either case, the data
     * contained in the argument will be written to a file (barring any errors,
     * of course).
     * @param fragment The fragment to process.
     */
    private static void processFragment(FileFragment fragment) {
        
        // if this is a new file, cleanup any old files and start a new 
        // output stream
        if (fragment.frag_num == 1) {
            
            // Check if currently processing a file
            if (!currentFileName.equals("")) {
                System.err.println("Got start of new file " + fragment.file_name +
                        " in the middle of processing file " + currentFileName);
                deleteCurrentFile();
            }
            resetForNextFile();
            closeStream();
            openStream(fragment);
            currentFileName = new String(fragment.file_name);
            errorWithCurrentFile = (outputStream == null);
        }
        
        // if there is an error with the current file, just return (don't annoy
        // with repeated error messages).
        if (errorWithCurrentFile) {
            return;
        }
        
        // if the fragment isn't for the expected file, then we've got an error
        if (!currentFileName.equals(fragment.file_name)) {
            // check to see if we got started in the middle of a transfer, this is
            // not technically an error
            System.err.println("Got fragment for file " + fragment.file_name + 
                    " while processing file " + currentFileName);
            resetForNextFile();
            errorWithCurrentFile = true;
            deleteCurrentFile();
            return;
        }
        
        // check if the incoming fragment number is the expected one
        if (nextfragmentNumberExpected != fragment.frag_num) {
            System.err.println("Got fragment " + fragment.frag_num + ": Expected fragment " 
                                + nextfragmentNumberExpected + " for file " + currentFileName);
            resetForNextFile();
            errorWithCurrentFile = true;
            deleteCurrentFile();
            return;
        }
        
        // update the next expected fragment number
        nextfragmentNumberExpected = fragment.frag_num + 1;
        
        try {
            // get the contents of this fragment
            fragment.frag.toArrayByte(buffer);           
            outputStream.write(buffer, 0, fragment.frag.size());

            // update the number of bytes written
            bytesWrittenCurrentFile += fragment.frag.size();
            
        } catch(IOException ioException) {
            ioException.printStackTrace();
            closeStream();
            errorWithCurrentFile = true;
            deleteCurrentFile();
        }
        
        // if this is the last fragment, flush any pending data and close the file
        if (fragment.frag_num == fragment.frag_total
            && !errorWithCurrentFile) {
            if (fragment.file_size != bytesWrittenCurrentFile) {
                System.err.println("Bytes written " + bytesWrittenCurrentFile +
                        " is not equal to expected size of file " + fragment.file_size +
                        " for file " + fragment.file_name);
                resetForNextFile();
                errorWithCurrentFile = true;
                deleteCurrentFile();
            } else {
                if (closeStream()) {
                    System.out.println("Successfully wrote file : " +
                        fragment.file_name);
                    System.out.println("\n File receiving endts at - >   [ "+ new Date().getTime() + " ] ms ");
                    new writeLog().writeOut("\n "
                    		+ LOG_DATE + " ( "+ Opt.DOMAIN_ID.asInt() +" ) "+ Opt.TOPIC_NAME.asString() + " - SUB - " + " => " +"File receiving endts at - >   [ "+ new Date().getTime() + " ] ms ");
                } else {
                    System.err.println("Failed to write file : " +
                            fragment.file_name);
                }
                resetForNextFile();
            }
        }
    }
    
    /**
     * Reset internal state members to prepare for the start of a new file.
     */
    private static void resetForNextFile() {
        bytesWrittenCurrentFile = 0;
        nextfragmentNumberExpected = 1;
        currentFileName = "";
    }
    
    /**
     * Open (and create if necessary) a file to store data from incoming
     * <code>FileFragment</code> objects.
     * @param fileDescription Incoming file metadata
     */
    private static void openStream(FileFragment fileDescription) {
        
        // ensure that the stream has been closed up properly
        closeStream();
        
        // check precondition
        if (fileDescription.file_name.length() < 1) {
            System.err.println("Cannot create file without a name.");
            return;
        }
        
        currentFile = new File(baseDirectory, fileDescription.file_name);
        File directory = currentFile.getParentFile();
        
        System.out.println("Opening file " + currentFile.getName() +
                " in directory " + directory.toString());
        new writeLog().writeOut("\n "
        		+ LOG_DATE + " ( "+ Opt.DOMAIN_ID.asInt() +" ) "+  Opt.TOPIC_NAME.asString() + " - SUB - " + " => " +  "Opening file " + currentFile.getName() +
                " in directory " + directory.toString());
        // if the directory (or directories) does not exist, attempt to create them
        if (directory != null) {
            if (!directory.exists()) {
                if (!directory.mkdirs()) {
                    System.err.println("Failed to create necessary directory : " +
                            directory);
                }
            }
        }
        
        // open the stream
        try {            
            outputStream = new BufferedOutputStream(new FileOutputStream(currentFile));
        } catch(IOException ioException) {
            ioException.printStackTrace();
            outputStream = null;
            currentFile = null;
        }
    }
    
    /**
     * Close the current stream.
     * @return true if the stream was successfully closed, false otherwise.
     */
    private static boolean closeStream() {
        boolean success = true;
        if (outputStream != null) {
            try {                
                outputStream.flush();
                outputStream.close();
                outputStream = null;
                
            } catch(IOException ioException) {
                ioException.printStackTrace();
                success = false;
            }
        }
        return success;
    }
    
    /**
     * Delete the current file being processed.
     */
    private static void deleteCurrentFile() {
        if (currentFile != null) {
            try {
                currentFile.delete();
            }catch(Exception e){
                System.err.println("Could not delete file : " + currentFile);
            }
        }
        currentFile = null;
    }
}

